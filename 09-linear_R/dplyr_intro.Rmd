---
title: "In-Depth Introduction to dplyr for Data Manipulation in R"
author: "Kevin Markham"
date: "Monday, August 18, 2014"
output: html_document
---

## Why do I use dplyr?

* great for data exploration and transformation
* intuitive to write and easy to read, especially when using the "chaining" syntax (covered below)
* fast on data frames


## dplyr functionality

* five basic verbs: filter, select, arrange, mutate, summarise (plus group_by)
* can work with data stored in databases
* inner join, left join, semi-join, anti-join (not covered below)
* window functions
* [better than plyr](http://blog.rstudio.org/2014/01/17/introducing-dplyr/) if you're only working with data frames (though it doesn't yet duplicate all of the plyr functionality)


## Loading dplyr and an example dataset

* dplyr will mask certain base functions
* if you also use plyr, load plyr first
* hflights is flights departing from two Houston airports in 2011

```{r}
# load packages
library(dplyr)
library(hflights)

# explore data
head(hflights)
```

* tbl_df creates a "local data frame"
* wrapper for a data frame that prints better

```{r}
# convert to tbl_df
flights <- tbl_df(hflights)

# printing a tbl_df only shows 10 rows and as many columns as can fit on your screen
flights

# you can specify that you want to see more rows
print(flights, n=20)

# convert to a normal data frame to see all of the columns
data.frame(head(flights))
```


## filter: Keep rows matching criteria

* base R approach to filtering forces you to repeat the data frame's name
* dplyr approach is simpler to write and read
* like all dplyr commands, first argument is a data frame
* dplyr does not preserve row names

```{r}
# base R approach to view all flights on January 1
flights[flights$Month==1 & flights$DayofMonth==1, ]

# dplyr approach (can use comma or ampersand to represent "AND" condition)
filter(flights, Month==1, DayofMonth==1)
filter(flights, Month==1 & DayofMonth==1)

# use pipe for OR condition (or %in% operator)
filter(flights, UniqueCarrier=="AA" | UniqueCarrier=="UA")
filter(flights, UniqueCarrier %in% c("AA", "UA"))
```


## select: Pick columns by name

* base R approach is awkward to type and to read
* dplyr approach uses similar syntax to filter
* identical to a SELECT in SQL

```{r}
# base R approach to select DepTime, ArrTime, and FlightNum columns
flights[, c("DepTime", "ArrTime", "FlightNum")]

# dplyr approach
select(flights, DepTime, ArrTime, FlightNum)

# use colon to select multiple contiguous columns, and use "contains" to match columns by name
select(flights, Year:DayofMonth, contains("Taxi"), contains("Delay"))

# "starts_with", "ends_with", and "matches" (for regular expressions) can also be used to match columns by name
```


## "Chaining" or "Pipelining"

* can perform multiple operations in one line by nesting
* or use `%>%` operator to write commands in a natural order

```{r}
# nesting method to select UniqueCarrier and DepDelay columns and filter for delays over 60 minutes
filter(select(flights, UniqueCarrier, DepDelay), DepDelay > 60)

# chaining method
flights %>% select(UniqueCarrier, DepDelay) %>% filter(DepDelay > 60)
```

* chaining increases readability significantly when there are many commands
* `%>%` operator can be read out loud as "then"
* this operator is automatically imported from the [magrittr](https://github.com/smbache/magrittr) package
* this operator can be used to replace nesting in any R command

```{r}
# create two vectors and calculate Euclidian distance between them
x1 <- 1:5; x2 <- 2:6
sqrt(sum((x1-x2)^2))

# chaining method
(x1-x2)^2 %>% sum() %>% sqrt()
```


## arrange: Reorder rows

```{r}
# base R approach to select UniqueCarrier and DepDelay columns and sort by DepDelay
flights[order(flights$DepDelay), c("UniqueCarrier", "DepDelay")]

# dplyr approach
flights %>% select(UniqueCarrier, DepDelay) %>% arrange(DepDelay)

# use desc() for descending
flights %>% select(UniqueCarrier, DepDelay) %>% arrange(desc(DepDelay))
```


## mutate: Add new variables

* create new variables that are functions of existing variables

```{r}
# base R approach to create a new variable Speed (in mph)
flights$Speed <- flights$Distance/flights$AirTime*60
flights[, c("Distance", "AirTime", "Speed")]

# dplyr approach (prints the new variable but does not store it)
flights %>% select(Distance, AirTime) %>% mutate(Speed=Distance/AirTime*60)

# store the new variable
flights <- flights %>% mutate(Speed=Distance/AirTime*60)
```


## summarise: Reduce variables to values

* primarily useful with data that has been grouped by one or more variables
* `group_by` creates the groups that will be operated on

```{r}
# base R approaches to calculate the average arrival delay to each destination
head(with(flights, tapply(ArrDelay, Dest, mean, na.rm=T)))
head(aggregate(ArrDelay ~ Dest, flights, mean))

# dplyr approach: create a table "grouped" by Dest, and then summarise each group by taking the mean of ArrDelay
flights %>% group_by(Dest) %>% summarise(avgdelay=mean(ArrDelay, na.rm=T))
```

* `summarise_each` allows you to apply the same summary function to multiple columns at once

```{r}
# for each carrier, calculate the percentage of flights cancelled or diverted
flights %>% group_by(UniqueCarrier) %>% summarise_each(funs(mean), Cancelled, Diverted)

# for each carrier, calculate the minimum and maximum arrival and departure delays
flights %>% group_by(UniqueCarrier) %>% summarise_each(funs(min(., na.rm=T), max(., na.rm=T)), matches("Delay"))
```

* function `n()` counts the number of rows in a group
* function `n_distinct(vector)` counts the number of unique rows in that vector

```{r}
# for each day of the year, count the total number of flights and sort in descending order
flights %>% group_by(Month, DayofMonth) %>% summarise(flight_count=n()) %>% arrange(desc(flight_count))

# rewrite more simply with the "tally" function
flights %>% group_by(Month, DayofMonth) %>% tally(sort = TRUE)

# for each destination, count the total number of flights and the number of distinct planes that flew there
flights %>% group_by(Dest) %>% summarise(flight_count=n(), plane_count=n_distinct(TailNum))
```

* grouping can sometimes be useful without summarising

```{r}
# for each destination, show the number of cancelled and not cancelled flights
flights %>% group_by(Dest) %>% select(Cancelled) %>% table() %>% head()
```


## Window Functions

* [window function](http://cran.r-project.org/web/packages/dplyr/vignettes/window-functions.html) is a variation of an aggregation function:
    * aggregation function (like `mean`) takes n inputs and returns 1 value
    * window function takes n inputs and returns n values
* includes ranking and ordering functions (like `min_rank`), offset functions (`lead` and `lag`), and cumulative aggregates (like `cummean`).

```{r}
# for each carrier, calculate which two days of the year they had their longest departure delays
flights %>% group_by(UniqueCarrier) %>% select(Month, DayofMonth, DepDelay) %>% filter(min_rank(desc(DepDelay)) <= 2) %>% arrange(UniqueCarrier, desc(DepDelay))

# note: smallest (not largest) value is ranked as 1, so you have to use "desc" to rank by largest value

# rewrite more simply with the "top_n" function
flights %>% group_by(UniqueCarrier) %>% select(Month, DayofMonth, DepDelay) %>% top_n(2) %>% arrange(UniqueCarrier, desc(DepDelay))
```

```{r}
# for each month, calculate the number of flights and the change from the previous month
flights %>% group_by(Month) %>% summarise(flight_count=n()) %>% mutate(change=flight_count-lag(flight_count))

# rewrite more simply with the "tally" function
flights %>% group_by(Month) %>% tally() %>% mutate(change=n-lag(n))
```


## Other Useful Convenience Functions

```{r}
# randomly sample a fixed number of rows
flights %>% sample_n(20)

# randomly sample a fraction of rows
flights %>% sample_frac(0.01)
```

```{r}
# base R approach to view the structure of an object
str(flights)

# dplyr approach: better formatting, and adapts to your screen width
glimpse(flights)
```


## Connecting to Remote Sources

* dplyr can connect to a remote database as if the data was loaded into a data frame
* currently supports SQLite, PostgreSQL/Redshift, MySQL/MariaDB, BigQuery, MonetDB

```{r}
# connect to an SQLite database
my_db <- src_sqlite("my_db.db")

# connect to the "hflights" table in that database
flights_db <- tbl(my_db, "hflights")
```

* use the exact same syntax for local data frames and databases

```{r}
# using a data frame
flights %>% select(UniqueCarrier, DepDelay) %>% arrange(desc(DepDelay))

# using the database
flights_db %>% select(UniqueCarrier, DepDelay) %>% arrange(desc(DepDelay))
```

* if you know SQL, you can write SQL commands directly
* dplyr can tell you the SQL it writes and the query execution plan

```{r}
# send SQL commands to the database
tbl(my_db, sql("SELECT * FROM hflights"))

# ask dplyr for the SQL commands
flights_db %>% select(UniqueCarrier, DepDelay) %>% arrange(desc(DepDelay)) %>% explain()
```


## Resources

* [Official reference manual and vignettes](http://cran.r-project.org/web/packages/dplyr/index.html)
* [July 2014 webinar about dplyr (and ggvis)](http://pages.rstudio.net/Webinar-Series-Recording-Essential-Tools-for-R.html)
* [GitHub repo](https://github.com/hadley/dplyr) and [list of releases](https://github.com/hadley/dplyr/releases)
